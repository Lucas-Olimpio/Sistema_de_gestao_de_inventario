
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `GoodsReceiptItem` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model GoodsReceiptItem
 * 
 */
export type GoodsReceiptItemModel = runtime.Types.Result.DefaultSelection<Prisma.$GoodsReceiptItemPayload>

export type AggregateGoodsReceiptItem = {
  _count: GoodsReceiptItemCountAggregateOutputType | null
  _avg: GoodsReceiptItemAvgAggregateOutputType | null
  _sum: GoodsReceiptItemSumAggregateOutputType | null
  _min: GoodsReceiptItemMinAggregateOutputType | null
  _max: GoodsReceiptItemMaxAggregateOutputType | null
}

export type GoodsReceiptItemAvgAggregateOutputType = {
  receivedQty: number | null
}

export type GoodsReceiptItemSumAggregateOutputType = {
  receivedQty: number | null
}

export type GoodsReceiptItemMinAggregateOutputType = {
  id: string | null
  goodsReceiptId: string | null
  productId: string | null
  receivedQty: number | null
  hasDivergence: boolean | null
}

export type GoodsReceiptItemMaxAggregateOutputType = {
  id: string | null
  goodsReceiptId: string | null
  productId: string | null
  receivedQty: number | null
  hasDivergence: boolean | null
}

export type GoodsReceiptItemCountAggregateOutputType = {
  id: number
  goodsReceiptId: number
  productId: number
  receivedQty: number
  hasDivergence: number
  _all: number
}


export type GoodsReceiptItemAvgAggregateInputType = {
  receivedQty?: true
}

export type GoodsReceiptItemSumAggregateInputType = {
  receivedQty?: true
}

export type GoodsReceiptItemMinAggregateInputType = {
  id?: true
  goodsReceiptId?: true
  productId?: true
  receivedQty?: true
  hasDivergence?: true
}

export type GoodsReceiptItemMaxAggregateInputType = {
  id?: true
  goodsReceiptId?: true
  productId?: true
  receivedQty?: true
  hasDivergence?: true
}

export type GoodsReceiptItemCountAggregateInputType = {
  id?: true
  goodsReceiptId?: true
  productId?: true
  receivedQty?: true
  hasDivergence?: true
  _all?: true
}

export type GoodsReceiptItemAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GoodsReceiptItem to aggregate.
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GoodsReceiptItems to fetch.
   */
  orderBy?: Prisma.GoodsReceiptItemOrderByWithRelationInput | Prisma.GoodsReceiptItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.GoodsReceiptItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` GoodsReceiptItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GoodsReceiptItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned GoodsReceiptItems
  **/
  _count?: true | GoodsReceiptItemCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: GoodsReceiptItemAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: GoodsReceiptItemSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GoodsReceiptItemMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GoodsReceiptItemMaxAggregateInputType
}

export type GetGoodsReceiptItemAggregateType<T extends GoodsReceiptItemAggregateArgs> = {
      [P in keyof T & keyof AggregateGoodsReceiptItem]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGoodsReceiptItem[P]>
    : Prisma.GetScalarType<T[P], AggregateGoodsReceiptItem[P]>
}




export type GoodsReceiptItemGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GoodsReceiptItemWhereInput
  orderBy?: Prisma.GoodsReceiptItemOrderByWithAggregationInput | Prisma.GoodsReceiptItemOrderByWithAggregationInput[]
  by: Prisma.GoodsReceiptItemScalarFieldEnum[] | Prisma.GoodsReceiptItemScalarFieldEnum
  having?: Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GoodsReceiptItemCountAggregateInputType | true
  _avg?: GoodsReceiptItemAvgAggregateInputType
  _sum?: GoodsReceiptItemSumAggregateInputType
  _min?: GoodsReceiptItemMinAggregateInputType
  _max?: GoodsReceiptItemMaxAggregateInputType
}

export type GoodsReceiptItemGroupByOutputType = {
  id: string
  goodsReceiptId: string
  productId: string
  receivedQty: number
  hasDivergence: boolean
  _count: GoodsReceiptItemCountAggregateOutputType | null
  _avg: GoodsReceiptItemAvgAggregateOutputType | null
  _sum: GoodsReceiptItemSumAggregateOutputType | null
  _min: GoodsReceiptItemMinAggregateOutputType | null
  _max: GoodsReceiptItemMaxAggregateOutputType | null
}

type GetGoodsReceiptItemGroupByPayload<T extends GoodsReceiptItemGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GoodsReceiptItemGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GoodsReceiptItemGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GoodsReceiptItemGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GoodsReceiptItemGroupByOutputType[P]>
      }
    >
  >



export type GoodsReceiptItemWhereInput = {
  AND?: Prisma.GoodsReceiptItemWhereInput | Prisma.GoodsReceiptItemWhereInput[]
  OR?: Prisma.GoodsReceiptItemWhereInput[]
  NOT?: Prisma.GoodsReceiptItemWhereInput | Prisma.GoodsReceiptItemWhereInput[]
  id?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  goodsReceiptId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  productId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  receivedQty?: Prisma.IntFilter<"GoodsReceiptItem"> | number
  hasDivergence?: Prisma.BoolFilter<"GoodsReceiptItem"> | boolean
  goodsReceipt?: Prisma.XOR<Prisma.GoodsReceiptScalarRelationFilter, Prisma.GoodsReceiptWhereInput>
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
}

export type GoodsReceiptItemOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  goodsReceiptId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  receivedQty?: Prisma.SortOrder
  hasDivergence?: Prisma.SortOrder
  goodsReceipt?: Prisma.GoodsReceiptOrderByWithRelationInput
  product?: Prisma.ProductOrderByWithRelationInput
}

export type GoodsReceiptItemWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.GoodsReceiptItemWhereInput | Prisma.GoodsReceiptItemWhereInput[]
  OR?: Prisma.GoodsReceiptItemWhereInput[]
  NOT?: Prisma.GoodsReceiptItemWhereInput | Prisma.GoodsReceiptItemWhereInput[]
  goodsReceiptId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  productId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  receivedQty?: Prisma.IntFilter<"GoodsReceiptItem"> | number
  hasDivergence?: Prisma.BoolFilter<"GoodsReceiptItem"> | boolean
  goodsReceipt?: Prisma.XOR<Prisma.GoodsReceiptScalarRelationFilter, Prisma.GoodsReceiptWhereInput>
  product?: Prisma.XOR<Prisma.ProductScalarRelationFilter, Prisma.ProductWhereInput>
}, "id">

export type GoodsReceiptItemOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  goodsReceiptId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  receivedQty?: Prisma.SortOrder
  hasDivergence?: Prisma.SortOrder
  _count?: Prisma.GoodsReceiptItemCountOrderByAggregateInput
  _avg?: Prisma.GoodsReceiptItemAvgOrderByAggregateInput
  _max?: Prisma.GoodsReceiptItemMaxOrderByAggregateInput
  _min?: Prisma.GoodsReceiptItemMinOrderByAggregateInput
  _sum?: Prisma.GoodsReceiptItemSumOrderByAggregateInput
}

export type GoodsReceiptItemScalarWhereWithAggregatesInput = {
  AND?: Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput | Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput[]
  OR?: Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput[]
  NOT?: Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput | Prisma.GoodsReceiptItemScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"GoodsReceiptItem"> | string
  goodsReceiptId?: Prisma.StringWithAggregatesFilter<"GoodsReceiptItem"> | string
  productId?: Prisma.StringWithAggregatesFilter<"GoodsReceiptItem"> | string
  receivedQty?: Prisma.IntWithAggregatesFilter<"GoodsReceiptItem"> | number
  hasDivergence?: Prisma.BoolWithAggregatesFilter<"GoodsReceiptItem"> | boolean
}

export type GoodsReceiptItemCreateInput = {
  id?: string
  receivedQty: number
  hasDivergence?: boolean
  goodsReceipt: Prisma.GoodsReceiptCreateNestedOneWithoutItemsInput
  product: Prisma.ProductCreateNestedOneWithoutGoodsReceiptItemsInput
}

export type GoodsReceiptItemUncheckedCreateInput = {
  id?: string
  goodsReceiptId: string
  productId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
  goodsReceipt?: Prisma.GoodsReceiptUpdateOneRequiredWithoutItemsNestedInput
  product?: Prisma.ProductUpdateOneRequiredWithoutGoodsReceiptItemsNestedInput
}

export type GoodsReceiptItemUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  goodsReceiptId?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemCreateManyInput = {
  id?: string
  goodsReceiptId: string
  productId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  goodsReceiptId?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemListRelationFilter = {
  every?: Prisma.GoodsReceiptItemWhereInput
  some?: Prisma.GoodsReceiptItemWhereInput
  none?: Prisma.GoodsReceiptItemWhereInput
}

export type GoodsReceiptItemOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type GoodsReceiptItemCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  goodsReceiptId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  receivedQty?: Prisma.SortOrder
  hasDivergence?: Prisma.SortOrder
}

export type GoodsReceiptItemAvgOrderByAggregateInput = {
  receivedQty?: Prisma.SortOrder
}

export type GoodsReceiptItemMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  goodsReceiptId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  receivedQty?: Prisma.SortOrder
  hasDivergence?: Prisma.SortOrder
}

export type GoodsReceiptItemMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  goodsReceiptId?: Prisma.SortOrder
  productId?: Prisma.SortOrder
  receivedQty?: Prisma.SortOrder
  hasDivergence?: Prisma.SortOrder
}

export type GoodsReceiptItemSumOrderByAggregateInput = {
  receivedQty?: Prisma.SortOrder
}

export type GoodsReceiptItemCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput> | Prisma.GoodsReceiptItemCreateWithoutProductInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyProductInputEnvelope
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
}

export type GoodsReceiptItemUncheckedCreateNestedManyWithoutProductInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput> | Prisma.GoodsReceiptItemCreateWithoutProductInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyProductInputEnvelope
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
}

export type GoodsReceiptItemUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput> | Prisma.GoodsReceiptItemCreateWithoutProductInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutProductInput | Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyProductInputEnvelope
  set?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  disconnect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  delete?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  update?: Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutProductInput | Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutProductInput | Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
}

export type GoodsReceiptItemUncheckedUpdateManyWithoutProductNestedInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput> | Prisma.GoodsReceiptItemCreateWithoutProductInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutProductInput[]
  upsert?: Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutProductInput | Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutProductInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyProductInputEnvelope
  set?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  disconnect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  delete?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  update?: Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutProductInput | Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutProductInput[]
  updateMany?: Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutProductInput | Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutProductInput[]
  deleteMany?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
}

export type GoodsReceiptItemCreateNestedManyWithoutGoodsReceiptInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput> | Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyGoodsReceiptInputEnvelope
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
}

export type GoodsReceiptItemUncheckedCreateNestedManyWithoutGoodsReceiptInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput> | Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyGoodsReceiptInputEnvelope
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
}

export type GoodsReceiptItemUpdateManyWithoutGoodsReceiptNestedInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput> | Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput[]
  upsert?: Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutGoodsReceiptInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyGoodsReceiptInputEnvelope
  set?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  disconnect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  delete?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  update?: Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutGoodsReceiptInput[]
  updateMany?: Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutGoodsReceiptInput[]
  deleteMany?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
}

export type GoodsReceiptItemUncheckedUpdateManyWithoutGoodsReceiptNestedInput = {
  create?: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput> | Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput[] | Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput[]
  connectOrCreate?: Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput[]
  upsert?: Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpsertWithWhereUniqueWithoutGoodsReceiptInput[]
  createMany?: Prisma.GoodsReceiptItemCreateManyGoodsReceiptInputEnvelope
  set?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  disconnect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  delete?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  connect?: Prisma.GoodsReceiptItemWhereUniqueInput | Prisma.GoodsReceiptItemWhereUniqueInput[]
  update?: Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpdateWithWhereUniqueWithoutGoodsReceiptInput[]
  updateMany?: Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutGoodsReceiptInput | Prisma.GoodsReceiptItemUpdateManyWithWhereWithoutGoodsReceiptInput[]
  deleteMany?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type GoodsReceiptItemCreateWithoutProductInput = {
  id?: string
  receivedQty: number
  hasDivergence?: boolean
  goodsReceipt: Prisma.GoodsReceiptCreateNestedOneWithoutItemsInput
}

export type GoodsReceiptItemUncheckedCreateWithoutProductInput = {
  id?: string
  goodsReceiptId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemCreateOrConnectWithoutProductInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  create: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput>
}

export type GoodsReceiptItemCreateManyProductInputEnvelope = {
  data: Prisma.GoodsReceiptItemCreateManyProductInput | Prisma.GoodsReceiptItemCreateManyProductInput[]
}

export type GoodsReceiptItemUpsertWithWhereUniqueWithoutProductInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  update: Prisma.XOR<Prisma.GoodsReceiptItemUpdateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedUpdateWithoutProductInput>
  create: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutProductInput>
}

export type GoodsReceiptItemUpdateWithWhereUniqueWithoutProductInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateWithoutProductInput, Prisma.GoodsReceiptItemUncheckedUpdateWithoutProductInput>
}

export type GoodsReceiptItemUpdateManyWithWhereWithoutProductInput = {
  where: Prisma.GoodsReceiptItemScalarWhereInput
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateManyMutationInput, Prisma.GoodsReceiptItemUncheckedUpdateManyWithoutProductInput>
}

export type GoodsReceiptItemScalarWhereInput = {
  AND?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
  OR?: Prisma.GoodsReceiptItemScalarWhereInput[]
  NOT?: Prisma.GoodsReceiptItemScalarWhereInput | Prisma.GoodsReceiptItemScalarWhereInput[]
  id?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  goodsReceiptId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  productId?: Prisma.StringFilter<"GoodsReceiptItem"> | string
  receivedQty?: Prisma.IntFilter<"GoodsReceiptItem"> | number
  hasDivergence?: Prisma.BoolFilter<"GoodsReceiptItem"> | boolean
}

export type GoodsReceiptItemCreateWithoutGoodsReceiptInput = {
  id?: string
  receivedQty: number
  hasDivergence?: boolean
  product: Prisma.ProductCreateNestedOneWithoutGoodsReceiptItemsInput
}

export type GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput = {
  id?: string
  productId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemCreateOrConnectWithoutGoodsReceiptInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  create: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput>
}

export type GoodsReceiptItemCreateManyGoodsReceiptInputEnvelope = {
  data: Prisma.GoodsReceiptItemCreateManyGoodsReceiptInput | Prisma.GoodsReceiptItemCreateManyGoodsReceiptInput[]
}

export type GoodsReceiptItemUpsertWithWhereUniqueWithoutGoodsReceiptInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  update: Prisma.XOR<Prisma.GoodsReceiptItemUpdateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedUpdateWithoutGoodsReceiptInput>
  create: Prisma.XOR<Prisma.GoodsReceiptItemCreateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedCreateWithoutGoodsReceiptInput>
}

export type GoodsReceiptItemUpdateWithWhereUniqueWithoutGoodsReceiptInput = {
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateWithoutGoodsReceiptInput, Prisma.GoodsReceiptItemUncheckedUpdateWithoutGoodsReceiptInput>
}

export type GoodsReceiptItemUpdateManyWithWhereWithoutGoodsReceiptInput = {
  where: Prisma.GoodsReceiptItemScalarWhereInput
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateManyMutationInput, Prisma.GoodsReceiptItemUncheckedUpdateManyWithoutGoodsReceiptInput>
}

export type GoodsReceiptItemCreateManyProductInput = {
  id?: string
  goodsReceiptId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemUpdateWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
  goodsReceipt?: Prisma.GoodsReceiptUpdateOneRequiredWithoutItemsNestedInput
}

export type GoodsReceiptItemUncheckedUpdateWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  goodsReceiptId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemUncheckedUpdateManyWithoutProductInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  goodsReceiptId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemCreateManyGoodsReceiptInput = {
  id?: string
  productId: string
  receivedQty: number
  hasDivergence?: boolean
}

export type GoodsReceiptItemUpdateWithoutGoodsReceiptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
  product?: Prisma.ProductUpdateOneRequiredWithoutGoodsReceiptItemsNestedInput
}

export type GoodsReceiptItemUncheckedUpdateWithoutGoodsReceiptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type GoodsReceiptItemUncheckedUpdateManyWithoutGoodsReceiptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  productId?: Prisma.StringFieldUpdateOperationsInput | string
  receivedQty?: Prisma.IntFieldUpdateOperationsInput | number
  hasDivergence?: Prisma.BoolFieldUpdateOperationsInput | boolean
}



export type GoodsReceiptItemSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  goodsReceiptId?: boolean
  productId?: boolean
  receivedQty?: boolean
  hasDivergence?: boolean
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["goodsReceiptItem"]>

export type GoodsReceiptItemSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  goodsReceiptId?: boolean
  productId?: boolean
  receivedQty?: boolean
  hasDivergence?: boolean
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["goodsReceiptItem"]>

export type GoodsReceiptItemSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  goodsReceiptId?: boolean
  productId?: boolean
  receivedQty?: boolean
  hasDivergence?: boolean
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}, ExtArgs["result"]["goodsReceiptItem"]>

export type GoodsReceiptItemSelectScalar = {
  id?: boolean
  goodsReceiptId?: boolean
  productId?: boolean
  receivedQty?: boolean
  hasDivergence?: boolean
}

export type GoodsReceiptItemOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "goodsReceiptId" | "productId" | "receivedQty" | "hasDivergence", ExtArgs["result"]["goodsReceiptItem"]>
export type GoodsReceiptItemInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}
export type GoodsReceiptItemIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}
export type GoodsReceiptItemIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  goodsReceipt?: boolean | Prisma.GoodsReceiptDefaultArgs<ExtArgs>
  product?: boolean | Prisma.ProductDefaultArgs<ExtArgs>
}

export type $GoodsReceiptItemPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "GoodsReceiptItem"
  objects: {
    goodsReceipt: Prisma.$GoodsReceiptPayload<ExtArgs>
    product: Prisma.$ProductPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    goodsReceiptId: string
    productId: string
    receivedQty: number
    hasDivergence: boolean
  }, ExtArgs["result"]["goodsReceiptItem"]>
  composites: {}
}

export type GoodsReceiptItemGetPayload<S extends boolean | null | undefined | GoodsReceiptItemDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload, S>

export type GoodsReceiptItemCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<GoodsReceiptItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GoodsReceiptItemCountAggregateInputType | true
  }

export interface GoodsReceiptItemDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoodsReceiptItem'], meta: { name: 'GoodsReceiptItem' } }
  /**
   * Find zero or one GoodsReceiptItem that matches the filter.
   * @param {GoodsReceiptItemFindUniqueArgs} args - Arguments to find a GoodsReceiptItem
   * @example
   * // Get one GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends GoodsReceiptItemFindUniqueArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemFindUniqueArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one GoodsReceiptItem that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {GoodsReceiptItemFindUniqueOrThrowArgs} args - Arguments to find a GoodsReceiptItem
   * @example
   * // Get one GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends GoodsReceiptItemFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GoodsReceiptItem that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemFindFirstArgs} args - Arguments to find a GoodsReceiptItem
   * @example
   * // Get one GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends GoodsReceiptItemFindFirstArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemFindFirstArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GoodsReceiptItem that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemFindFirstOrThrowArgs} args - Arguments to find a GoodsReceiptItem
   * @example
   * // Get one GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends GoodsReceiptItemFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more GoodsReceiptItems that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all GoodsReceiptItems
   * const goodsReceiptItems = await prisma.goodsReceiptItem.findMany()
   * 
   * // Get first 10 GoodsReceiptItems
   * const goodsReceiptItems = await prisma.goodsReceiptItem.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const goodsReceiptItemWithIdOnly = await prisma.goodsReceiptItem.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends GoodsReceiptItemFindManyArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a GoodsReceiptItem.
   * @param {GoodsReceiptItemCreateArgs} args - Arguments to create a GoodsReceiptItem.
   * @example
   * // Create one GoodsReceiptItem
   * const GoodsReceiptItem = await prisma.goodsReceiptItem.create({
   *   data: {
   *     // ... data to create a GoodsReceiptItem
   *   }
   * })
   * 
   */
  create<T extends GoodsReceiptItemCreateArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemCreateArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many GoodsReceiptItems.
   * @param {GoodsReceiptItemCreateManyArgs} args - Arguments to create many GoodsReceiptItems.
   * @example
   * // Create many GoodsReceiptItems
   * const goodsReceiptItem = await prisma.goodsReceiptItem.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends GoodsReceiptItemCreateManyArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many GoodsReceiptItems and returns the data saved in the database.
   * @param {GoodsReceiptItemCreateManyAndReturnArgs} args - Arguments to create many GoodsReceiptItems.
   * @example
   * // Create many GoodsReceiptItems
   * const goodsReceiptItem = await prisma.goodsReceiptItem.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many GoodsReceiptItems and only return the `id`
   * const goodsReceiptItemWithIdOnly = await prisma.goodsReceiptItem.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends GoodsReceiptItemCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a GoodsReceiptItem.
   * @param {GoodsReceiptItemDeleteArgs} args - Arguments to delete one GoodsReceiptItem.
   * @example
   * // Delete one GoodsReceiptItem
   * const GoodsReceiptItem = await prisma.goodsReceiptItem.delete({
   *   where: {
   *     // ... filter to delete one GoodsReceiptItem
   *   }
   * })
   * 
   */
  delete<T extends GoodsReceiptItemDeleteArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemDeleteArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one GoodsReceiptItem.
   * @param {GoodsReceiptItemUpdateArgs} args - Arguments to update one GoodsReceiptItem.
   * @example
   * // Update one GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends GoodsReceiptItemUpdateArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemUpdateArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more GoodsReceiptItems.
   * @param {GoodsReceiptItemDeleteManyArgs} args - Arguments to filter GoodsReceiptItems to delete.
   * @example
   * // Delete a few GoodsReceiptItems
   * const { count } = await prisma.goodsReceiptItem.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends GoodsReceiptItemDeleteManyArgs>(args?: Prisma.SelectSubset<T, GoodsReceiptItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GoodsReceiptItems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many GoodsReceiptItems
   * const goodsReceiptItem = await prisma.goodsReceiptItem.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends GoodsReceiptItemUpdateManyArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GoodsReceiptItems and returns the data updated in the database.
   * @param {GoodsReceiptItemUpdateManyAndReturnArgs} args - Arguments to update many GoodsReceiptItems.
   * @example
   * // Update many GoodsReceiptItems
   * const goodsReceiptItem = await prisma.goodsReceiptItem.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more GoodsReceiptItems and only return the `id`
   * const goodsReceiptItemWithIdOnly = await prisma.goodsReceiptItem.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends GoodsReceiptItemUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one GoodsReceiptItem.
   * @param {GoodsReceiptItemUpsertArgs} args - Arguments to update or create a GoodsReceiptItem.
   * @example
   * // Update or create a GoodsReceiptItem
   * const goodsReceiptItem = await prisma.goodsReceiptItem.upsert({
   *   create: {
   *     // ... data to create a GoodsReceiptItem
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the GoodsReceiptItem we want to update
   *   }
   * })
   */
  upsert<T extends GoodsReceiptItemUpsertArgs>(args: Prisma.SelectSubset<T, GoodsReceiptItemUpsertArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptItemClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of GoodsReceiptItems.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemCountArgs} args - Arguments to filter GoodsReceiptItems to count.
   * @example
   * // Count the number of GoodsReceiptItems
   * const count = await prisma.goodsReceiptItem.count({
   *   where: {
   *     // ... the filter for the GoodsReceiptItems we want to count
   *   }
   * })
  **/
  count<T extends GoodsReceiptItemCountArgs>(
    args?: Prisma.Subset<T, GoodsReceiptItemCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GoodsReceiptItemCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a GoodsReceiptItem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GoodsReceiptItemAggregateArgs>(args: Prisma.Subset<T, GoodsReceiptItemAggregateArgs>): Prisma.PrismaPromise<GetGoodsReceiptItemAggregateType<T>>

  /**
   * Group by GoodsReceiptItem.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GoodsReceiptItemGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends GoodsReceiptItemGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: GoodsReceiptItemGroupByArgs['orderBy'] }
      : { orderBy?: GoodsReceiptItemGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, GoodsReceiptItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoodsReceiptItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the GoodsReceiptItem model
 */
readonly fields: GoodsReceiptItemFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for GoodsReceiptItem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__GoodsReceiptItemClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  goodsReceipt<T extends Prisma.GoodsReceiptDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GoodsReceiptDefaultArgs<ExtArgs>>): Prisma.Prisma__GoodsReceiptClient<runtime.Types.Result.GetResult<Prisma.$GoodsReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  product<T extends Prisma.ProductDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProductDefaultArgs<ExtArgs>>): Prisma.Prisma__ProductClient<runtime.Types.Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the GoodsReceiptItem model
 */
export interface GoodsReceiptItemFieldRefs {
  readonly id: Prisma.FieldRef<"GoodsReceiptItem", 'String'>
  readonly goodsReceiptId: Prisma.FieldRef<"GoodsReceiptItem", 'String'>
  readonly productId: Prisma.FieldRef<"GoodsReceiptItem", 'String'>
  readonly receivedQty: Prisma.FieldRef<"GoodsReceiptItem", 'Int'>
  readonly hasDivergence: Prisma.FieldRef<"GoodsReceiptItem", 'Boolean'>
}
    

// Custom InputTypes
/**
 * GoodsReceiptItem findUnique
 */
export type GoodsReceiptItemFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter, which GoodsReceiptItem to fetch.
   */
  where: Prisma.GoodsReceiptItemWhereUniqueInput
}

/**
 * GoodsReceiptItem findUniqueOrThrow
 */
export type GoodsReceiptItemFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter, which GoodsReceiptItem to fetch.
   */
  where: Prisma.GoodsReceiptItemWhereUniqueInput
}

/**
 * GoodsReceiptItem findFirst
 */
export type GoodsReceiptItemFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter, which GoodsReceiptItem to fetch.
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GoodsReceiptItems to fetch.
   */
  orderBy?: Prisma.GoodsReceiptItemOrderByWithRelationInput | Prisma.GoodsReceiptItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GoodsReceiptItems.
   */
  cursor?: Prisma.GoodsReceiptItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` GoodsReceiptItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GoodsReceiptItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GoodsReceiptItems.
   */
  distinct?: Prisma.GoodsReceiptItemScalarFieldEnum | Prisma.GoodsReceiptItemScalarFieldEnum[]
}

/**
 * GoodsReceiptItem findFirstOrThrow
 */
export type GoodsReceiptItemFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter, which GoodsReceiptItem to fetch.
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GoodsReceiptItems to fetch.
   */
  orderBy?: Prisma.GoodsReceiptItemOrderByWithRelationInput | Prisma.GoodsReceiptItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GoodsReceiptItems.
   */
  cursor?: Prisma.GoodsReceiptItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` GoodsReceiptItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GoodsReceiptItems.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GoodsReceiptItems.
   */
  distinct?: Prisma.GoodsReceiptItemScalarFieldEnum | Prisma.GoodsReceiptItemScalarFieldEnum[]
}

/**
 * GoodsReceiptItem findMany
 */
export type GoodsReceiptItemFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter, which GoodsReceiptItems to fetch.
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GoodsReceiptItems to fetch.
   */
  orderBy?: Prisma.GoodsReceiptItemOrderByWithRelationInput | Prisma.GoodsReceiptItemOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing GoodsReceiptItems.
   */
  cursor?: Prisma.GoodsReceiptItemWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` GoodsReceiptItems from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GoodsReceiptItems.
   */
  skip?: number
  distinct?: Prisma.GoodsReceiptItemScalarFieldEnum | Prisma.GoodsReceiptItemScalarFieldEnum[]
}

/**
 * GoodsReceiptItem create
 */
export type GoodsReceiptItemCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * The data needed to create a GoodsReceiptItem.
   */
  data: Prisma.XOR<Prisma.GoodsReceiptItemCreateInput, Prisma.GoodsReceiptItemUncheckedCreateInput>
}

/**
 * GoodsReceiptItem createMany
 */
export type GoodsReceiptItemCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many GoodsReceiptItems.
   */
  data: Prisma.GoodsReceiptItemCreateManyInput | Prisma.GoodsReceiptItemCreateManyInput[]
}

/**
 * GoodsReceiptItem createManyAndReturn
 */
export type GoodsReceiptItemCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * The data used to create many GoodsReceiptItems.
   */
  data: Prisma.GoodsReceiptItemCreateManyInput | Prisma.GoodsReceiptItemCreateManyInput[]
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * GoodsReceiptItem update
 */
export type GoodsReceiptItemUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * The data needed to update a GoodsReceiptItem.
   */
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateInput, Prisma.GoodsReceiptItemUncheckedUpdateInput>
  /**
   * Choose, which GoodsReceiptItem to update.
   */
  where: Prisma.GoodsReceiptItemWhereUniqueInput
}

/**
 * GoodsReceiptItem updateMany
 */
export type GoodsReceiptItemUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update GoodsReceiptItems.
   */
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateManyMutationInput, Prisma.GoodsReceiptItemUncheckedUpdateManyInput>
  /**
   * Filter which GoodsReceiptItems to update
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * Limit how many GoodsReceiptItems to update.
   */
  limit?: number
}

/**
 * GoodsReceiptItem updateManyAndReturn
 */
export type GoodsReceiptItemUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * The data used to update GoodsReceiptItems.
   */
  data: Prisma.XOR<Prisma.GoodsReceiptItemUpdateManyMutationInput, Prisma.GoodsReceiptItemUncheckedUpdateManyInput>
  /**
   * Filter which GoodsReceiptItems to update
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * Limit how many GoodsReceiptItems to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * GoodsReceiptItem upsert
 */
export type GoodsReceiptItemUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * The filter to search for the GoodsReceiptItem to update in case it exists.
   */
  where: Prisma.GoodsReceiptItemWhereUniqueInput
  /**
   * In case the GoodsReceiptItem found by the `where` argument doesn't exist, create a new GoodsReceiptItem with this data.
   */
  create: Prisma.XOR<Prisma.GoodsReceiptItemCreateInput, Prisma.GoodsReceiptItemUncheckedCreateInput>
  /**
   * In case the GoodsReceiptItem was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.GoodsReceiptItemUpdateInput, Prisma.GoodsReceiptItemUncheckedUpdateInput>
}

/**
 * GoodsReceiptItem delete
 */
export type GoodsReceiptItemDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
  /**
   * Filter which GoodsReceiptItem to delete.
   */
  where: Prisma.GoodsReceiptItemWhereUniqueInput
}

/**
 * GoodsReceiptItem deleteMany
 */
export type GoodsReceiptItemDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GoodsReceiptItems to delete
   */
  where?: Prisma.GoodsReceiptItemWhereInput
  /**
   * Limit how many GoodsReceiptItems to delete.
   */
  limit?: number
}

/**
 * GoodsReceiptItem without action
 */
export type GoodsReceiptItemDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GoodsReceiptItem
   */
  select?: Prisma.GoodsReceiptItemSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GoodsReceiptItem
   */
  omit?: Prisma.GoodsReceiptItemOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GoodsReceiptItemInclude<ExtArgs> | null
}
